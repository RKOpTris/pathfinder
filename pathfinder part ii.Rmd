---
title: 'pathfinder: an algorithm for finding the most efficient path between waypoints - Part II - Being less stupid'
author: "RKOpTris"
date: '2024-04-21'
output: rmarkdown::github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Abstract

This is a continuation of a journey to write an algorithm from scratch which finds the most efficient path between a set of waypoints with a variety of paths between them. (I'm adding to this document intermittently and iteratively and represents a work in progress.)

Welcome to Part Deux!

## Introduction

In the first part of this series we wrote a not-so-clever algorithm to find the shortest distance from a start/finish waypoint that passed through a group of other waypoints at least once. It managed it but did not find the best route, nor did it do it very quickly. Here we explore how we can improve upon our original design.

### Methods and R code

Firstly, let's load in the needed libraries and the functions we defined in the Part I.

```{r, initial_funs}
library(dplyr)
library(stringr)
source("generate_points.R")
source("generate_paths.R")
source("get_pos.R")
source("visualise_paths.R")
source("get_distance.R")
source("init_points.R")
source("init_paths.R")
source("error_code_for_plot.R")
source("error_code_summary.R")
source("fail_run.R")
source("find_path.R")
source("get_path_length.R")
source("get_path.R")
source("plot_error_codes.R")
source("plot_path.R")
source("report_success.R")
source("reset_global_vars.R")
source("reset_run_vars.R")
source("str_to_waypoints.R")
source("waypoints_to_str.R")
source("succeed_run.R")
source("withSeed.R")
```

Our model in Part I succeeded in finding a reasonably efficient route with a distance of 16.2. That is, however, not the best route which comes in under 16. Further, it took 1.5 minutes to complete using all the time available to it (defined by that maximum number of runs). We also saw the main reason for failure initially was that waypoints were being visited too many times (which is set as a default of 3 in the global vars environment and had an error code of F-MW). This error code gradually changed too "F-XD" denoting that the maximum-allowed distance had been reached. The maximum-allowed distance is set iteratively, which each start-finish success needing to find an equivalent or shorter route. It makes sense then that the model fails more often as the maximum-allowed route gets shorter.

To make the algorithm a bit more discerning we can introduce the idea of a penalty that is imposed on a waypoint when it has been visited. To do this, all waypoints are assigned a probability that they will be selected as the next waypoint. This starts as 1 in all cases, and so from $A$ if connected points $B$ and $C$ have an equal probability, then the likelihood the of the algorithm travelling to either of them is equal. Because the algorithm has been at $A$, we will impose a multiplier of 0.25 (an arbitrary penalty), so 1 * 0.25 = 0.25. When the algorithm moves to $B$ that same penalty is incurred. Now, if $B$ connects to $C$ and $D$, and also to $A$, $C$ and $D$ have no penalty, 1, but as waypoint $A$ has a penalty imposed, it will be less probably that the algorithm will select that waypoint. So it moves to $C$ or $D$ and the process is continued. If equal penalties have been imposed on all waypoint choices from any given point, then the probability of choosing any particular waypoint to move to is equal again.

In this way we keep the algorithm moving, rather than allowing it to "dither"; moving needlessly between points it has already visited. As we saw from the error codes and the paths is took, we can see that this was an issue.

```{r, run_algo_1_penalty, fig.width=9, fig.height=9}
global_vars <- new.env()
run_vars <- new.env()

my_points <- init_points()
my_paths <- init_paths()
visualise_paths()
run1 <- withSeed(find_path(max_runs = 50000, visit_penalty = 0.25))
plot_path(run1$best_route)
run1[1:(length(run1) - 1)]
library(ggplot2)
plot_error_codes(run1)
```

Same set of points but a new path, this time setting the start from $I$. Note that 
$G$ is solely connected to $F$, as is $I$ to $C$, and $H$ to $I$.
```{r, run_algo_2, fig.width=9, fig.height=9}
my_points <- init_points()
my_paths <- init_paths()
my_paths <- init_paths()
visualise_paths()
run2 <- withSeed(find_path(start_waypoint = "i", max_visits = 3, max_runs = 50000))
plot_path(run2$best_route)
run2[1:(length(run2) - 1)]
plot_error_codes(run2)
```